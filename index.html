<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Nuri Hangeul Global IME</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      background: radial-gradient(circle at top, #e8f0ff 0, #f5f5f5 55%, #e0e0e0 100%);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 32px 16px;
      color: #222;
    }
    .app {
      width: 100%;
      max-width: 1100px;
      background: #ffffff;
      border-radius: 18px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.16);
      padding: 20px 24px 24px;
    }
    .app-header {
      border-bottom: 1px solid #ececec;
      padding-bottom: 10px;
      margin-bottom: 14px;
    }
    .app-title {
      margin: 0;
      font-size: 22px;
      font-weight: 650;
      letter-spacing: 0.02em;
    }
    .app-subtitle {
      margin: 4px 0 0;
      font-size: 13px;
      color: #666;
    }
    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    button {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #888;
      background: #ffffff;
      font-size: 13px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
    }
    button.primary {
      background: #2563eb;
      color: #ffffff;
      border-color: #2563eb;
      box-shadow: 0 2px 6px rgba(37,99,235,0.35);
    }
    button.primary:hover {
      background: #1d4ed8;
      box-shadow: 0 3px 10px rgba(37,99,235,0.45);
      transform: translateY(-1px);
    }
    button:hover {
      background: #f3f4f6;
    }
    button:active {
      transform: translateY(0);
      box-shadow: none;
    }
    .file-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px dashed #999;
      cursor: pointer;
      background: #fafafa;
    }
    .file-label:hover {
      background: #f3f4f6;
    }
    .file-label input[type="file"] {
      display: none;
    }
    .toolbar-spacer {
      flex: 1;
    }
    .status {
      font-size: 12px;
      color: #555;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 210px;
    }
    .status-line {
      line-height: 1.3;
    }
    .canvas-wrapper {
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #e0e0e0;
      background: #fff;
    }
    canvas {
      display: block;
      background: white;
      cursor: crosshair;
    }
    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: #777;
    }
    #ime {
      position: absolute;
      left: -9999px;
      top: -9999px;
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div class="app">
  <header class="app-header">
    <h1 class="app-title">Nuri Hangeul Global IME</h1>
    <p class="app-subtitle">
      ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ ê¸°ì¤€ì ì„ ì •í•˜ê³ , í‚¤ë³´ë“œë¡œ ë‚±ê¸€ìë¥¼ ì°ì€ ë’¤ JSONìœ¼ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì›Œë“œ ë¬¸ì„œì—ì„œ ì‘ì„±í•œ ê²ƒì„ ë³µì‚¬í•´ì„œ ë¶™ì—¬ë„ ë©ë‹ˆë‹¤. <br>
	  ì˜¤ë¥¸ìª½ ì•„ë˜ì— ìˆëŠ” <b>ìŒì„± ì…ë ¥</b>ì˜ <b>ì‹œì‘</b> ë‹¨ì¶”ë¥¼ ëˆ„ë¥´ë©´ ë§ˆì´í¬ë¥¼ í†µí•´ì„œ ì—¬ëŸ¬ ì–¸ì–´ë¥¼ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. <br>
	  [ì£¼ì˜] ì´ ê¸€ìë“¤ì€ í…ìŠ¤íŠ¸ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ì‹¤ì œë¡œëŠ” ì´ë¯¸ì§€ ëª¨ìŒì…ë‹ˆë‹¤.
     <br>
	  <span style="color:#444;">í‹°ë² íŠ¸ì–´(à½–à½¼à½‘à¼‹à½¦à¾à½‘à¼)ëŠ” í‚¤ë³´ë“œ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.</span>
    </p>
  </header>

  <div class="toolbar">
    <button id="newBtn" title="ëª¨ë“  ê¸€ìë¥¼ ì§€ìš°ê³  ìƒˆë¡œ ì‹œì‘í•©ë‹ˆë‹¤.">
      ğŸ§¹ ìƒˆ ìº”ë²„ìŠ¤
    </button>
    <button id="saveBtn" class="primary" title="í˜„ì¬ ë°°ì¹˜ë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.">
      ğŸ’¾ JSON ì €ì¥
    </button>
    <label class="file-label" title="ì €ì¥í•´ ë‘” JSONì„ ë¶ˆëŸ¬ì™€ì„œ ë‹¤ì‹œ í¸ì§‘í•©ë‹ˆë‹¤.">
	   ğŸ“‚ JSON ë¶ˆëŸ¬ì˜¤ê¸°
      <input type="file" id="loadInput" accept=".json,application/json">
    </label>
    <label class="file-label" title="TXT(íƒ­ êµ¬ë¶„) íŒŒì¼ì„ ë¶ˆëŸ¬ì™€ì„œ ìº”ë²„ìŠ¤ì— ë³µì›í•©ë‹ˆë‹¤.">
      ğŸ“„ TXT ë¶ˆëŸ¬ì˜¤ê¸°
      <input type="file" id="loadTxtInput" accept=".txt,text/plain">
    </label>
	<button id="saveJpgBtn" title="í˜„ì¬ í™”ë©´ì„ JPG ì´ë¯¸ì§€ë¡œ ì €ì¥í•©ë‹ˆë‹¤.">
  ğŸ–¼ JPG ì €ì¥
</button>

    <button id="font50Btn" title="ì…ë ¥ ê¸€ì í¬ê¸°: 50px (ìƒˆë¡œ ì…ë ¥ë˜ëŠ” ê¸€ìì— ì ìš©)">A50</button>
    <button id="font25Btn" title="ì…ë ¥ ê¸€ì í¬ê¸°: 25px (ìƒˆë¡œ ì…ë ¥ë˜ëŠ” ê¸€ìì— ì ìš©)">A25</button>

    <button id="undoBtn" title="Ctrl+Zì™€ ê°™ìŠµë‹ˆë‹¤. ì§ì „ ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤.">
      â†©ï¸ ë˜ëŒë¦¬ê¸°
    </button>

    <div class="toolbar-spacer"></div>

    <div class="status">
      <div class="status-line" id="statusChars">ê¸€ì: 0ê°œ</div>
      <div class="status-line" id="statusPos">ì…ë ¥ ìœ„ì¹˜: ì—†ìŒ</div>
            <div class="status-line" id="statusFont">í°íŠ¸: 50px</div>
    </div>
  </div>

  <div class="canvas-wrapper">
    <canvas id="canvas" width="1000" height="180" tabindex="0"></canvas>
  </div>
  
  <!-- ========================= -->
<!-- ì˜›í•œê¸€ ë‚±ê¸€ì íŒ”ë ˆíŠ¸ -->
<!-- ========================= -->
<div class="palette">
  <button class="jamo-btn" data-char="ã…¿">ã…¿</button>
  <button class="jamo-btn" data-char="ã††">ã††</button>
  <button class="jamo-btn" data-char="ã†">ã†</button>
  <button class="jamo-btn" data-char="ã…¸">ã…¸</button>
  <button class="jamo-btn" data-char="ã…¹">ã…¹</button>
  <button class="jamo-btn" data-char="ã†„">ã†„</button>
  <button class="jamo-btn" data-char="ã…±">ã…±</button>
  <button class="jamo-btn" data-char="á„›">á„›</button>
  <button class="jamo-btn" data-char="Ëš">Ëš</button>
  <button class="jamo-btn" data-char="Ë‡">Ë‡</button>
  <button class="jamo-btn" data-char="Â´">Â´</button>
  <button class="jamo-btn" data-char="`">`</button>
  <button class="jamo-btn" data-char="á„¼">á„¼</button>
  <button class="jamo-btn" data-char="á…">á…</button>
  <button class="jamo-btn" data-char="á…”">á…”</button>
</div>


  <p class="hint">
    ì‚¬ìš©ë²•: (1) ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ ì…ë ¥ ìœ„ì¹˜ë¥¼ ì •í•©ë‹ˆë‹¤. (2) í•œê¸€/ì˜ë¬¸ì„ ì…ë ¥í•˜ë©´ í•´ë‹¹ ìœ„ì¹˜ì— ê¸€ìê°€ ì°íˆê³  ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤. 
	(3) ê¸€ìì˜ í¬ê¸°ëŠ” <b>A50</b>ê³¼ <b>A25</b> ì¤‘ì—ì„œ ê³ ë¥´ì„¸ìš”. (4) ëˆ„ë¦¬í•œê¸€ì—ì„œ í•„ìš”í•œ <b>ì˜›ê¸€ì</b>ëŠ” ìº”ë²„ìŠ¤ì˜ ì•„ë˜ìª½ì— ìˆëŠ” ë‹¨ì¶”ë¥¼ ëˆŒëŸ¬ì„œ ì…ë ¥í•©ë‹ˆë‹¤. 
    (5) ì˜ëª» ì…ë ¥í–ˆìœ¼ë©´ <b>Backspace</b>ë¡œ ë§ˆì§€ë§‰ ê¸€ìë¥¼ ì§€ìš¸ ìˆ˜ ìˆê³ , <b>Ctrl+Z</b>ë¡œ ì´ì „ ìƒíƒœë¡œ ë˜ëŒë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  </p>
</div>

<input id="ime" autocomplete="off" />

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const ime = document.getElementById("ime");
  // -------------------------
  // Keyboard ì…ë ¥ ì•ˆì •í™”
  // -------------------------
  canvas.tabIndex = 0;

  let imeComposing = false;

  function ensureIMEFocus() {
    try { ime.focus({ preventScroll: true }); } catch(e) { try { ime.focus(); } catch(_) {} }
  }

  // IME ì¡°í•© ìƒíƒœ ì¶”ì  (í•œê¸€/ì¼ë³¸ì–´/ì¤‘êµ­ì–´ ë“±)
  ime.addEventListener("compositionstart", () => { imeComposing = true; });
  ime.addEventListener("compositionend", (e) => {
    imeComposing = false;
    // í•œê¸€ ë“± IME ì¡°í•©ì´ "í™•ì •"ë˜ëŠ” ì‹œì ì— ìº”ë²„ìŠ¤ë¡œ ë°˜ì˜
    const v = (e && typeof e.data === "string" && e.data) ? e.data : (ime.value || "");
    if (v && v.trim() !== "") {
      insertTextToCanvas(v);
      ime.value = "";
    }
  });

  const saveBtn = document.getElementById("saveBtn");
  const loadInput = document.getElementById("loadInput");
  const newBtn = document.getElementById("newBtn");
  const undoBtn = document.getElementById("undoBtn");

  const font50Btn = document.getElementById("font50Btn");
  const font25Btn = document.getElementById("font25Btn");
  const statusChars = document.getElementById("statusChars");
  const statusPos = document.getElementById("statusPos");

  
  const statusFont = document.getElementById("statusFont");
const w = canvas.width;
  const h = canvas.height;

  // -------------------------
  // 1. ëˆˆê¸ˆ ê·¸ë¦¬ê¸°
  // -------------------------
  function drawGrid(step) {
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, w, h);

    for (let x = 0; x <= w; x += step) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.strokeStyle = (x % 50 === 0) ? "#d1d5db" : "#e5e7eb";
      ctx.lineWidth = (x % 50 === 0) ? 1.2 : 0.6;
      ctx.stroke();
    }
    for (let y = 0; y <= h; y += step) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.strokeStyle = (y % 50 === 0) ? "#d1d5db" : "#e5e7eb";
      ctx.lineWidth = (y % 50 === 0) ? 1.2 : 0.6;
      ctx.stroke();
    }
  }

  drawGrid(5);

  // -------------------------
  // 2. ê¸€ì ë°°ì¹˜ ë°ì´í„° êµ¬ì¡° + íˆìŠ¤í† ë¦¬
  // -------------------------
  let placedChars = [];   // {char, x, y}
  let currentPos = null;  // {x, y}

  // ê°„ë‹¨í•œ undo ìŠ¤íƒ (ì´ì „ ìƒíƒœ ì €ì¥)
  let historyStack = [];

  const korFont = "'ì´ì‚¬ë§Œë£¨', 'Apple SD Gothic Neo', 'Noto Sans KR Black', 'Noto Sans KR', 'Noto Sans', 'Noto Sans Arabic', 'Noto Naskh Arabic', 'Noto Sans Devanagari', 'Mangal', 'Noto Sans Ethiopic', 'Noto Sans Cherokee', 'Noto Sans Adlam', 'Noto Sans Tagalog', 'Segoe UI', system-ui, sans-serif";
  ctx.textAlign = "center";

  let currentFontSize = 50; // 50px / 25px ì „í™˜ (ìƒˆë¡œ ì…ë ¥ë˜ëŠ” ê¸€ìì— ì ìš©)

  function advanceX(sizePx) {
    // ê¸€ì í­ ì¶”ì •: í°íŠ¸ í¬ê¸°ì˜ ì•½ 0.6ë°°
    return Math.max(8, Math.round(sizePx * 1.0));
  }

  ctx.textBaseline = "middle";

  // -------------------------
  // STT/ë¶™ì—¬ë„£ê¸°/í‚¤ì…ë ¥ ê³µí†µ: ìë™ ì¤„ë°”ê¿ˆ ê¸°ì¤€
  // -------------------------
  const WRAP_X = 900;       // xê°€ ì´ ê°’ì„ ë„˜ìœ¼ë©´ ë‹¤ìŒ ì¤„ë¡œ ì´ë™
  const WRAP_START_X = 50; // ì¤„ë°”ê¿ˆ í›„ ì‹œì‘ x(ì™¼ìª½ ì—¬ë°±)
  const LEFT_MARGIN = WRAP_START_X; // ëª¨ë“  í–‰ì˜ ì‹œì‘ x (ì™¼ìª½ ì—¬ë°±)
  const LINE_GAP = 1.4;    // ì¤„ ê°„ê²©(í°íŠ¸ í¬ê¸° ë°°ìˆ˜)


  // -------------------------
  // 2-5. RTL/Complex script helpers (Arabic / Devanagari)
  // - CanvasëŠ” ë¬¸ìì—´ ì „ì²´ë¥¼ fillTextí•  ë•Œ ê²°í•©/ì…°ì´í•‘ì´ í›¨ì”¬ ì˜ ë©ë‹ˆë‹¤.
  // - ì•„ëì–´ëŠ” RTL ë°©í–¥ + ì˜¤ë¥¸ìª½ ì •ë ¬ë¡œ ê·¸ë¦½ë‹ˆë‹¤.
  // -------------------------
  function getVoiceLang() {
    const sel = document.getElementById("voiceLang");
    return sel ? sel.value : "";
  }

  function hasArabic(text) {
    return /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text);
  }

  function hasDevanagari(text) {
    return /[\u0900-\u097F]/.test(text);
  }

  

  function hasThai(text) {
    return /[\u0E00-\u0E7F]/.test(text);
  }

  function hasLao(text) {
    return /[\u0E80-\u0EFF]/.test(text);
  }

  function hasKhmer(text) {
    return /[\u1780-\u17FF]/.test(text);
  }

  function hasMyanmar(text) {
    return /[\u1000-\u109F\uAA60-\uAA7F]/.test(text);
  }

  // ë°ë°”ë‚˜ê°€ë¦¬(íŒë””ì–´/ë„¤íŒ”ì–´) + íƒœêµ­ì–´ + ë¼ì˜¤ì–´ + í¬ë©”ë¥´ì–´ + ë¯¸ì–€ë§ˆì–´
  function hasComplexScript(text) {
    return hasDevanagari(text) || hasThai(text) || hasLao(text) || hasKhmer(text) || hasMyanmar(text);
  }
function isRTLText(text) {
    return getVoiceLang() === "ar-SA" || hasArabic(text);
  }

  function snap5(n) { return Math.round(n / 5) * 5; }

  function measureTextWidth(text, size) {
    ctx.save();
    ctx.font = size + "px " + korFont;
    const w = ctx.measureText(text).width;
    ctx.restore();
    return w;
  }


  // ìƒíƒœ ê¹Šì€ ë³µì‚¬
  function cloneState() {
    return {
      placedChars: placedChars.map(c => ({ char: c.char, x: c.x, y: c.y, size: c.size, run: !!c.run, dir: c.dir })),
      currentPos: currentPos ? { x: currentPos.x, y: currentPos.y } : null
    };
  }

  function pushHistory() {
    historyStack.push(cloneState());
    // ë„ˆë¬´ ê¸¸ì–´ì§€ì§€ ì•Šë„ë¡ ìµœëŒ€ 100ë‹¨ê³„ê¹Œì§€ë§Œ ìœ ì§€
    if (historyStack.length > 100) {
      historyStack.shift();
    }
  }

  function undo() {
    if (historyStack.length === 0) return;
    const prev = historyStack.pop();
    placedChars = prev.placedChars;
    currentPos = prev.currentPos;
    redraw();
  }

  // -------------------------
  // ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
  // -------------------------
  function updateStatus() {
    statusChars.textContent = "ê¸€ì: " + placedChars.length + "ê°œ";
    if (currentPos) {
      statusPos.textContent = "ì…ë ¥ ìœ„ì¹˜: x=" + currentPos.x + ", y=" + currentPos.y;
    } else {
      statusPos.textContent = "ì…ë ¥ ìœ„ì¹˜: ì—†ìŒ";
    }

    statusFont.textContent = "í°íŠ¸: " + currentFontSize + "px";
  }

  // -------------------------
  // 3. ì „ì²´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
  // -------------------------
  function redraw() {
    drawGrid(5);

    ctx.fillStyle = "#000000";
    placedChars.forEach(c => {
      const size = (typeof c.size === "number") ? c.size : currentFontSize;
      ctx.font = size + "px " + korFont;

      if (c && c.run) {
        ctx.save();
        const rtl = (c.dir === "rtl") || isRTLText(String(c.char || ""));
        ctx.direction = rtl ? "rtl" : "ltr";
        ctx.textAlign = rtl ? "right" : "left";
        ctx.fillText(String(c.char || ""), c.x, c.y);
        ctx.restore();
      } else {
        ctx.textAlign = "center";
        ctx.direction = "ltr";
        ctx.fillText(c.char, c.x, c.y);
      }
    });

    if (currentPos) {
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(currentPos.x, currentPos.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    updateStatus();
  }

  // -------------------------
  // 4. ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ìœ„ì¹˜ ì„ íƒ
  // -------------------------
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;
    return { x, y };
  }

  const appRoot = document.querySelector(".app");
  if (appRoot) {
    appRoot.addEventListener("mousedown", (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      if (tag === "select" || tag === "option" || tag === "button" || tag === "input" || tag === "textarea" || tag === "label") return;
      ensureIMEFocus();
    });
  }

  canvas.addEventListener("click", (evt) => {
    const pos = getCanvasPos(evt);

    const gridX = Math.round(pos.x / 5) * 5;
    const gridY = Math.round(pos.y / 5) * 5;

    currentPos = { x: gridX, y: gridY };

    ime.value = "";
    ensureIMEFocus();

    redraw();
  });

  // -------------------------
  // 5-1. IME ì¡°í•© ì™„ë£Œ (í•œê¸€ ë“±)
  // -------------------------
  ime.addEventListener("compositionend", (evt) => {
    if (!currentPos) return;
    const text = evt.data;
    if (!text) return;

    pushHistory();

    const rtl = isRTLText(text);
    const complex = rtl || hasComplexScript(text);

    if (complex) {
      const width = measureTextWidth(text, currentFontSize);

      placedChars.push({
        char: text,
        x: currentPos.x,
        y: currentPos.y,
        size: currentFontSize,
        run: true,
        dir: rtl ? "rtl" : "ltr"
      });

      currentPos = {
        x: rtl ? (currentPos.x - width) : (currentPos.x + width),
        y: currentPos.y
      };

      ime.value = "";
      redraw();
      return;
    }
  });
// -------------------------
  // ë¶™ì—¬ë„£ê¸°ìš© í…ìŠ¤íŠ¸ ì‚½ì… í•¨ìˆ˜
  // - STT(ìŒì„± ì¸ì‹) / ë¶™ì—¬ë„£ê¸° / ê¸°íƒ€ í˜¸ì¶œì´ ëª¨ë‘ ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
  // - x=WRAP_Xë¥¼ ë„˜ìœ¼ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ ì¤„ë¡œ ì´ë™í•©ë‹ˆë‹¤.
  // -------------------------
  function insertTextToCanvas(text) {
    if (!currentPos || !text) return;

    pushHistory();

    const rtl = isRTLText(text);
    const complex = rtl || hasComplexScript(text);

    // === run ë‹¨ìœ„(ì•„ëì–´Â·ë°ë°”ë‚˜ê°€ë¦¬Â·íƒœêµ­ì–´Â·ë¼ì˜¤Â·í¬ë©”ë¥´Â·ë¯¸ì–€ë§ˆ ë“±) ===
    if (complex) {
      const width = measureTextWidth(text, currentFontSize);

      // âœ… LTRì¼ ë•Œë§Œ ìë™ ì¤„ë°”ê¿ˆ ì ìš© (RTLì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì§„í–‰)
      if (!rtl && currentPos.x + width > WRAP_X) {
        currentPos = { x: snap5(Math.max(WRAP_START_X, LEFT_MARGIN)), y: snap5(currentPos.y + currentFontSize * LINE_GAP) };
      }

      placedChars.push({
        char: text,
        x: currentPos.x,
        y: currentPos.y,
        size: currentFontSize,
        run: true,
        dir: rtl ? "rtl" : "ltr"
      });

      currentPos = {
        x: rtl ? (currentPos.x - width) : (currentPos.x + width),
        y: currentPos.y
      };

      redraw();
      ime.value = "";
      ime.focus();
      return;
    }

    // === ì¼ë°˜ ë¬¸ì ë‹¨ìœ„ ===
    for (const ch of text) {
      const adv = advanceX(currentFontSize);

      // âœ… ìë™ ì¤„ë°”ê¿ˆ
      if (currentPos.x + adv > WRAP_X) {
        currentPos = {
          x: snap5(LEFT_MARGIN),
          y: snap5(currentPos.y + currentFontSize * LINE_GAP)
        };
      }

      placedChars.push({
        char: ch,
        x: currentPos.x,
        y: currentPos.y,
        size: currentFontSize
      });

      currentPos = {
        x: currentPos.x + adv,
        y: currentPos.y
      };
    }

    redraw();
    ime.value = "";
    ime.focus();
  }


// =========================
// ì˜›í•œê¸€ íŒ”ë ˆíŠ¸ ë²„íŠ¼ ì²˜ë¦¬
// =========================
document.querySelectorAll(".jamo-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const ch = btn.dataset.char;
    if (!currentPos) return;

    pushHistory();

    placedChars.push({
      char: ch,
      x: currentPos.x,
      y: currentPos.y,
      size: currentFontSize
    });

    currentPos = {
      x: currentPos.x + advanceX(currentFontSize),
      y: currentPos.y
    };

    redraw();
    ime.focus();
  });
});


  // -------------------------
  // Ctrl+V ë¶™ì—¬ë„£ê¸° ì²˜ë¦¬
  // -------------------------
  ime.addEventListener("paste", (evt) => {
    const text = (evt.clipboardData || window.clipboardData).getData("text");
    if (!text) return;

    evt.preventDefault();   // inputì— ë¶™ì§€ ì•Šê²Œ
    insertTextToCanvas(text);
  });


  // -------------------------
  // 5-2. IME ì•ˆ ì“°ëŠ” ê²½ìš°(ì˜ì–´, ìˆ«ì ë“±) + Undo/Backspace ì²˜ë¦¬
  // -------------------------
  
  function keyHandler(evt) {
    // IME(í•œê¸€/ì¼ë³¸ì–´/ì¤‘êµ­ì–´ ë“±) ì¡°í•© ì…ë ¥ì€ ë¸Œë¼ìš°ì €ì— ë§¡ê¹ë‹ˆë‹¤.
    // - keyCode 229(IME), isComposing, ë˜ëŠ” ìˆ¨ê¹€ IME ì…ë ¥ì°½(#ime) ëŒ€ìƒ ì´ë²¤íŠ¸ëŠ” ê°€ë¡œì±„ì§€ ì•ŠìŒ
    if (evt && (evt.isComposing || evt.keyCode === 229 || imeComposing)) return;

// ============================
    // í™”ì‚´í‘œ í‚¤ë¡œ ë¹¨ê°„ ì (ì…ë ¥ ìœ„ì¹˜) ì´ë™
    // - ìŠ¤ëƒ… ê°„ê²©: 5px (í˜„ì¬ ëˆˆê¸ˆ/ìŠ¤ëƒ…ê³¼ ë™ì¼)
    // ============================
    const step = 5;
    if (evt.key === "ArrowLeft" || evt.key === "ArrowRight" || evt.key === "ArrowUp" || evt.key === "ArrowDown") {
      evt.preventDefault(); // í™”ë©´ ìŠ¤í¬ë¡¤ ë°©ì§€

      // ì•„ì§ ìœ„ì¹˜ë¥¼ ì°ì§€ ì•Šì•˜ìœ¼ë©´ (0,0)ì—ì„œ ì‹œì‘
      if (!currentPos) currentPos = { x: 0, y: 0 };

      if (evt.key === "ArrowLeft")  currentPos.x -= step;
      if (evt.key === "ArrowRight") currentPos.x += step;
      if (evt.key === "ArrowUp")    currentPos.y -= step;
      if (evt.key === "ArrowDown")  currentPos.y += step;

      // ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ í´ë¨í”„
      currentPos.x = Math.max(0, Math.min(w, currentPos.x));
      currentPos.y = Math.max(0, Math.min(h, currentPos.y));

      redraw();
      ime.focus(); // IME(í•œê¸€ ì…ë ¥) í¬ì»¤ìŠ¤ ìœ ì§€
      return;
    }


    // Ctrl+Z ë˜ëŒë¦¬ê¸°
    if (evt.ctrlKey && (evt.key === "z" || evt.key === "Z")) {
      evt.preventDefault();
      undo();
      return;
    }

    // Ctrl+1 / Ctrl+2 : "ë§ˆì§€ë§‰ ê¸€ì"ë§Œ í¬ê¸° ë³€ê²½ (ê°œë³„ ê¸€ì í¬ê¸° ì§€ì›)
    if (evt.ctrlKey && (evt.key === "1" || evt.key === "2")) {
      evt.preventDefault();
      if (placedChars.length === 0) return;
      pushHistory();
      const newSize = (evt.key === "1") ? 50 : 25;
      placedChars[placedChars.length - 1].size = newSize;
      redraw();
      return;
    }

    // ============================
    // Ctrl+V / Cmd+V : ë¶™ì—¬ë„£ê¸°
    // - 'v'ê°€ ë¬¸ìë¡œ ì°íˆëŠ” ê²ƒì„ ë°©ì§€
    // - ì‹¤ì œ í…ìŠ¤íŠ¸ëŠ” paste ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬
    // ============================
    if ((evt.ctrlKey || evt.metaKey) && (evt.key === "v" || evt.key === "V")) {
      ime.focus();
      return;
    }


    // Backspace: ë§ˆì§€ë§‰ ê¸€ì ì‚­ì œ
    if (evt.key === "Backspace") {
      evt.preventDefault();
      if (placedChars.length === 0) return;

      // í˜„ì¬ ìƒíƒœ ì €ì¥ í›„ ë§ˆì§€ë§‰ ê¸€ì ì œê±°
      pushHistory();
      const removed = placedChars.pop();
      // ì‚­ì œí•œ ê¸€ì ìœ„ì¹˜ë¥¼ í˜„ì¬ ì…ë ¥ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¼
      currentPos = { x: removed.x, y: removed.y };
      redraw();
      return;
    }

    if (evt.isComposing || evt.key === "Process") return;
    if (!currentPos) return;

    const ch = evt.key;
    if (!ch || ch.length !== 1) return;

    // ì¼ë°˜ ê¸€ì ì…ë ¥ ì „ ìƒíƒœ ì €ì¥
    pushHistory();

    // keydownìœ¼ë¡œ ì²˜ë¦¬í•˜ë¯€ë¡œ, ìˆ¨ê¹€ IME inputì— ë¬¸ìê°€ ë‚¨ì§€ ì•Šê²Œ ê¸°ë³¸ ë™ì‘ì„ ë§‰ìŠµë‹ˆë‹¤.
    evt.preventDefault();

    
    // ì¼ë°˜ ê¸€ì ì…ë ¥ ì „ ìƒíƒœ ì €ì¥
    pushHistory();

    placedChars.push({
      char: ch,
      x: currentPos.x,
      y: currentPos.y,
      size: currentFontSize
    });

    currentPos = { x: currentPos.x + advanceX(currentFontSize), y: currentPos.y };
    redraw();
  }

  // í‚¤ë³´ë“œ ì…ë ¥ì´ UI(ë“œë¡­ë‹¤ìš´/ë²„íŠ¼) í¬ì»¤ìŠ¤ ë•Œë¬¸ì— ëŠê¸°ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´
  // window ìº¡ì²˜ ë‹¨ê³„ì—ì„œë„ í•¨ê»˜ ìˆ˜ì‹ í•©ë‹ˆë‹¤.
  window.addEventListener("keydown", keyHandler, true);
  // -------------------------
  // 6. ìƒˆ ìº”ë²„ìŠ¤ (ì´ˆê¸°í™”)
  // -------------------------
  function clearCanvasData() {
    placedChars = [];
    currentPos = null;
    historyStack = [];
    redraw();
  }

  newBtn.addEventListener("click", clearCanvasData);
  undoBtn.addEventListener("click", undo);

  // í°íŠ¸ í¬ê¸°(ìƒˆ ì…ë ¥ ê¸€ìì— ì ìš©)
  font50Btn.addEventListener("click", () => {
    currentFontSize = 50;
    redraw();
	ime.focus();   // â­ í•œê¸€ ì…ë ¥ ë³µêµ¬ í•µì‹¬
  });
  font25Btn.addEventListener("click", () => {
    currentFontSize = 25;
    redraw();
	ime.focus();   // â­ í•œê¸€ ì…ë ¥ ë³µêµ¬ í•µì‹¬
  });

// -------------------------
  // 7. JSON ì €ì¥
  // -------------------------
  async function saveJSON() {
  // âš ï¸ íŒŒì¼ ì €ì¥ ëŒ€í™”ìƒì(showSaveFilePicker)ëŠ” ë³´í†µ localhost/HTTPSì—ì„œë§Œ ì•ˆì •ì ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
  // file:// ë¡œ ì§ì ‘ ì—´ì—ˆìœ¼ë©´ ë‹¤ìš´ë¡œë“œ(í´ë°±)ë¡œ ì €ì¥ë©ë‹ˆë‹¤.
  // 1) JSON ë‚´ìš© ë§Œë“¤ê¸°
  const data = {
    placedChars,
    currentFontSize,
    paperType: (typeof paperType !== "undefined") ? paperType : null
  };
  const jsonString = JSON.stringify(data, null, 2);

  // ê¸°ë³¸ ì œì•ˆ íŒŒì¼ëª…(ìë™ë²ˆí˜¸ ëŒ€ì‹  "ì œì•ˆ"ë§Œ)
  const d = new Date();
  const pad = (n) => String(n).padStart(2, "0");
  const suggested =
    "nuri_" +
    d.getFullYear() + pad(d.getMonth() + 1) + pad(d.getDate()) + "_" +
    pad(d.getHours()) + pad(d.getMinutes()) +
    ".json";

  // âœ… Chrome/Edge: í´ë” ì„ íƒ + íŒŒì¼ëª… ë³€ê²½ ê°€ëŠ¥í•œ ì €ì¥ ëŒ€í™”ìƒì
  if (window.showSaveFilePicker) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: suggested,
        types: [{
          description: "JSON",
          accept: { "application/json": [".json"] }
        }]
      });
      const writable = await handle.createWritable();
      await writable.write(jsonString);
      await writable.close();
    } catch (err) {
      // ì‚¬ìš©ìê°€ ì·¨ì†Œí•˜ë©´ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•ŠìŒ
      console.warn("Save canceled/failed:", err);
      return;
    }
  } else {
    // ğŸ” fallback: ë¯¸ì§€ì› ë¸Œë¼ìš°ì €ëŠ” íŒŒì¼ëª…ë§Œ ë¬¼ì–´ë³´ê³  ë‹¤ìš´ë¡œë“œ
    const filename = prompt("ì €ì¥í•  íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (.json í¬í•¨)", suggested) || suggested;
    const jsonBlob = new Blob([jsonString], { type: "application/json" });
    const jsonUrl = URL.createObjectURL(jsonBlob);

    const a = document.createElement("a");
    a.href = jsonUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(jsonUrl), 1000);
  }

  // 2) ì €ì¥ í›„ ìº”ë²„ìŠ¤ ë¹„ìš°ê¸°
  clearCanvasData();
}


  saveBtn.addEventListener("click", saveJSON);

const saveJpgBtn = document.getElementById("saveJpgBtn");

function saveJPG() {
  // ì €ì¥ ì „ ë¹¨ê°„ ì ì„ ì ì‹œ ìˆ¨ê¸°ê³  ìº”ë²„ìŠ¤ë¥¼ ë‹¤ì‹œ ê·¸ë¦¼
  const savedPos = currentPos;
  currentPos = null;
  redraw();

  // JPG ë°ì´í„° ìƒì„±
  const dataURL = canvas.toDataURL("image/jpeg", 0.95);  // 95% í’ˆì§ˆ

  // ë‹¤ì‹œ ë¹¨ê°„ ì  ë³µêµ¬
  currentPos = savedPos;
  redraw();

  // Blob ë³€í™˜
  const byteString = atob(dataURL.split(",")[1]);
  const mimeString = dataURL.split(",")[0].split(":")[1].split(";")[0];
  const buffer = new ArrayBuffer(byteString.length);
  const dataArray = new Uint8Array(buffer);

  for (let i = 0; i < byteString.length; i++) {
    dataArray[i] = byteString.charCodeAt(i);
  }

  const blob = new Blob([buffer], { type: mimeString });
  const url = URL.createObjectURL(blob);

  // ë‹¤ìš´ë¡œë“œ
  const link = document.createElement("a");
  link.href = url;
  link.download = "drawing_canvas.jpg";
  link.click();

  URL.revokeObjectURL(url);
}

saveJpgBtn.addEventListener("click", saveJPG);

 // -------------------------
  // 8-0. TXT ë¶ˆëŸ¬ì˜¤ê¸° + ë³µì› (íƒ­ êµ¬ë¶„: char\tx\ty\tsize[optional])
  // -------------------------
  loadTxtInput.addEventListener("change", () => {
    const file = loadTxtInput.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const text = String(e.target.result || "");
        const lines = text.replace(/\r\n?/g, "\n").split("\n");

        const newChars = [];
        let posFromTxt = null;
        for (const line of lines) {
          if (!line.trim() && line !== "\t\t" && line !== "\t\t\t") continue; // ë¹ˆ ì¤„ ìŠ¤í‚µ

          // íƒ­ ê¸°ì¤€ ë¶„ë¦¬ (ì €ì¥ í˜•ì‹: char\tx\ty\tsize)
          const parts = line.split("\t");

          // #POS\tx\ty í˜•ì‹ì´ë©´ í˜„ì¬ ì…ë ¥ ìœ„ì¹˜ë¡œ í•´ì„
          if (parts[0] === "#POS") {
            const px = Number(parts[1]);
            const py = Number(parts[2]);
            if (Number.isFinite(px) && Number.isFinite(py)) {
              posFromTxt = { x: px, y: py };
            }
            continue;
          }

          // parts[0]ê°€ ë¹ˆ ë¬¸ìì—´ì´ë©´ "ê³µë°±" ê¸€ìë¡œ ì·¨ê¸‰
          const ch = (parts[0] === undefined) ? "" : (parts[0] === "" ? " " : parts[0]);

          const x = Number(parts[1]);
          const y = Number(parts[2]);
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

          const sizeRaw = parts[3];
          const size = (sizeRaw !== undefined && String(sizeRaw).trim() !== "") ? Number(sizeRaw) : currentFontSize;
          newChars.push({
            char: ch,
            x,
            y,
            size: Number.isFinite(size) ? size : currentFontSize
          });
        }

        placedChars = newChars;

        // currentPos ë³µì›: TXTì— #POSê°€ ìˆìœ¼ë©´ ê·¸ ê°’ì„ ì‚¬ìš©, ì—†ìœ¼ë©´ "ë§ˆì§€ë§‰ ê¸€ì ë‹¤ìŒ ìœ„ì¹˜"ë¡œ ê³„ì‚°
        if (posFromTxt) {
          currentPos = posFromTxt;
        } else if (placedChars.length > 0) {
          const last = placedChars[placedChars.length - 1];
          const lastSize = (typeof last.size === "number") ? last.size : currentFontSize;
          currentPos = { x: last.x + advanceX(lastSize), y: last.y };
        } else {
          currentPos = null;
        }

        historyStack = [];
        redraw();
        alert("TXT ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ! ê¸€ì ê°œìˆ˜: " + placedChars.length + "ê°œ");
      } catch (err) {
        console.error(err);
        alert("TXT íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + err.message);
      }
    };
    reader.readAsText(file, "utf-8");
    // ê°™ì€ íŒŒì¼ì„ ë‹¤ì‹œ ì„ íƒí•´ë„ changeê°€ ë°œìƒí•˜ë„ë¡ ê°’ ì´ˆê¸°í™”
    loadTxtInput.value = "";
  });


  // -------------------------
  // 9. JSON ë¶ˆëŸ¬ì˜¤ê¸° + ë³µì›
  // -------------------------
  loadInput.addEventListener("change", () => {
    const file = loadInput.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const text = e.target.result;
        const data = JSON.parse(text);

        if (!data || !Array.isArray(data.placedChars)) {
          alert("ì˜¬ë°”ë¥´ì§€ ì•Šì€ JSON í˜•ì‹ì…ë‹ˆë‹¤.");
          return;
        }

        placedChars = data.placedChars.map(c => ({
          char: c.char,
          x: c.x,
          y: c.y,
          size: (typeof c.size === "number") ? c.size : 50
        }));
        currentPos = data.currentPos || null;
        historyStack = [];

        redraw();
        alert("JSON ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ! ê¸€ì ê°œìˆ˜: " + placedChars.length + "ê°œ");
      } catch (err) {
        console.error(err);
        alert("JSON íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + err.message);
      }
    };
    reader.readAsText(file, "utf-8");
  });

  // ìµœì´ˆ ìƒíƒœ í‘œì‹œ
  updateStatus();
  
  
/* === Simplified â†’ Traditional Chinese (very small OpenCC-like map) === */
/* ì‹¤ì‚¬ìš©ì—ì„œ ìì£¼ ë‚˜ì˜¤ëŠ” ê¸€ì ìœ„ì£¼ (í™•ì¥ ê°€ëŠ¥) */
const S2T_MAP = {
  "æ±‰":"æ¼¢","è¯­":"èª","é©¬":"é¦¬","é—¨":"é–€","å›½":"åœ‹","ä¸œ":"æ±","é£":"é¢¨",
  "äº‘":"é›²","ä¹¦":"æ›¸","è½¦":"è»Š","å":"å¾Œ","å‘":"ç™¼","å°":"è‡º","ä¸‡":"è¬",
  "ä¸":"èˆ‡","ä¸“":"å°ˆ","ä¸š":"æ¥­","ä¸­":"ä¸­","å›½":"åœ‹","ç½‘":"ç¶²",
  "ç®€":"ç°¡","ä½“":"é«”","ç”µ":"é›»","è¯":"è©±","ç”»":"ç•«","è§":"è¦‹",
  "å¬":"è½","çˆ±":"æ„›","å­¦":"å­¸","ä¹ ":"ç¿’","è¿™":"é€™","é‡Œ":"è£¡"
};

function simplifiedToTraditional(text) {
  return text.split("").map(ch => S2T_MAP[ch] || ch).join("");
}
</script>


<!-- === Multilingual Voice Input Panel === -->
<div id="voicePanel" style="position:fixed;right:16px;bottom:16px;z-index:9999;background:#fff;border:1px solid #ddd;border-radius:14px;padding:12px 14px;box-shadow:0 4px 16px rgba(0,0,0,.15);font-family:system-ui;;min-width:280px">
  <div style="font-weight:700;margin-bottom:6px;">ğŸ™ ìŒì„± ì…ë ¥</div>
  <select id="voiceLang" style="width:100%;margin-bottom:6px;">
    <option value="ko-KR">í•œêµ­ì–´ (ko-KR)</option>
<option value="ja-JP">æ—¥æœ¬èª (ja-JP)</option>
<option value="en-US">English (en-US)</option>
<option value="zh-CN">ä¸­æ–‡(ç®€ä½“) (zh-CN)</option>
<option value="zh-TW">ä¸­æ–‡(ç¹é«”) (zh-TW)</option>
<option value="es-ES">EspaÃ±ol (es-ES)</option>
<option value="ru-RU">Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ru-RU)</option>
<option value="mn-MN">ĞœĞ¾Ğ½Ğ³Ğ¾Ğ» (mn-MN)</option>
<option value="id-ID">Bahasa Indonesia (id-ID)</option>
<option value="vi-VN">Tiáº¿ng Viá»‡t (vi-VN)</option>
<option value="hi-IN">à¤¹à¤¿à¤¨à¥à¤¦à¥€ (hi-IN)</option>
<option value="ne-NP">à¤¨à¥‡à¤ªà¤¾à¤²à¥€ (ne-NP)</option>
<option value="gu-IN">àª—à«àªœàª°àª¾àª¤à«€ (gu-IN)</option>
<option value="ar-SA">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ar-SA)</option>
<option value="he-IL">×¢×‘×¨×™×ª (he-IL)</option>

<option value="fa-IR">ÙØ§Ø±Ø³ÛŒ (fa-IR)</option>
<option value="am-ET">áŠ áˆ›áˆ­áŠ› (am-ET)</option>
<option value="chr-US">á£á³á© (chr-US)</option>
<option value="ceb-PH">Binisaya/Cebuano (ceb-PH)</option>
<option value="ff-Adlm-SN" data-keyboard-only="1" data-note="adlam">ğ¤†ğ¤µğ¤¤ğ¤¢ğ¥„ğ¤ª Adlam/Fulfulde (í‚¤ë³´ë“œ ì „ìš©)</option>
<option value="tl-Tglg-PH" data-keyboard-only="1" data-note="baybayin">áœŠáœŒáœ”áœŠáœŒáœ’áœˆáœ” Baybayin (í‚¤ë³´ë“œ ì „ìš©)</option>

<option value="th-TH">à¹„à¸—à¸¢ (Thai) (th-TH)</option>
<option value="km-KH">ááŸ’á˜áŸ‚áš (Khmer) (km-KH)</option>
<option value="my-MM">á€™á€¼á€”á€ºá€™á€¬ (Myanmar) (my-MM)</option>
<option value="lo-LA">àº¥àº²àº§ (Lao) (lo-LA)</option>
    <option value="bo-IN" data-keyboard-only="1" data-note="tibetan">à½–à½¼à½‘à¼‹à½¦à¾à½‘à¼ Tibetan (bo-IN)</option>
  <option value="manchu" data-keyboard-only="1" data-note="manchu">á ®á  á ¨á µá¡  Manchu (í‚¤ë³´ë“œ ì „ìš©)</option>
</select>
  <div style="display:flex;gap:6px;flex-wrap:wrap;">
    <button id="vStart">ì‹œì‘</button>
    <button id="vStop" disabled>ì¤‘ì§€</button>
    <button id="vSpeak" title="ë§ˆì§€ë§‰ ì…ë ¥(ë˜ëŠ” ì„ íƒ ì–¸ì–´ ì˜ˆë¬¸)ì„ ì½ìŠµë‹ˆë‹¤.">ğŸ”Š ì½ê¸°</button>
  </div>
  <div style="margin-top:6px;font-size:11px;color:#666;line-height:1.35;">
    </div>
  <div id="vStatus" style="margin-top:6px;font-size:12px;color:#444;">ëŒ€ê¸°</div>
</div>

<script>
(function() {
  
  // =========================
  // TTS (Text-to-Speech) helper
  // =========================
  const WRAP_X = 900;   // STT ìë™ ì¤„ë°”ê¿ˆ ê¸°ì¤€ x
const LINE_GAP = 1.4; // ì¤„ ê°„ê²© ë°°ìˆ˜
  
  function speakText(text, lang) {
    try {
      if (!("speechSynthesis" in window)) return;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = lang || "en-US";
      const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
      const v = voices.find(v => v.lang === u.lang) || voices.find(v => (v.lang || "").startsWith((u.lang || "").split("-")[0]));
      if (v) u.voice = v;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    } catch (e) {
      console.warn("TTS failed:", e);
    }
  }

  function snap5(n) { return Math.round(n / 5) * 5; }

  // Thai demo phrase â†’ romanization + Hangul transcription (handcrafted for demo)
  const THAI_DEMO = "à¸šà¸£à¸£à¸—à¸±à¸”à¸à¸²à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢ à¹€à¸¥à¹ˆà¸¡ 1";
  const THAI_DEMO_ROMA = "banthatthan phasa thai lem 1";
  const THAI_DEMO_HANGUL = "ë°˜ë‚«íƒ„ íŒŒì‹¸ íƒ€ì´ ë ˜ ëŠì—‰";

  function insertMultilineAt(startX, startY, lines) {
    if (!currentPos) currentPos = { x: startX, y: startY };
    const oldSize = currentFontSize;

    for (let i = 0; i < lines.length; i++) {
      const L = lines[i];
      if (typeof L.size === "number") currentFontSize = L.size;

      currentPos = { x: startX, y: snap5(startY + i * (oldSize * 1.4)) };
      insertTextToCanvas(L.text);
    }

    currentFontSize = oldSize;
  }

  function handleThaiWithTranslit(text) {
    if (!currentPos) return;
    const startX = currentPos.x;
    const startY = currentPos.y;

    insertMultilineAt(startX, startY, [
      { text: text, size: currentFontSize },
      { text: THAI_DEMO_ROMA, size: 25 },
      { text: THAI_DEMO_HANGUL, size: 25 }
    ]);

    // Speak original Thai
    speakText(text, "th-TH");
  }
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    document.getElementById("vStatus").textContent = "ë¸Œë¼ìš°ì € ë¯¸ì§€ì›";
    return;
  }

  const recog = new SpeechRecognition();
  recog.continuous = true;
  recog.interimResults = false;

  const langSel = document.getElementById("voiceLang");
  const startBtn = document.getElementById("vStart");
  const stopBtn = document.getElementById("vStop");
  const statusEl = document.getElementById("vStatus");

  
  // -------------------------
  // Keyboard-only languages (no STT/TTS) notice
  // -------------------------
  function selectedOption() {
    return langSel.options[langSel.selectedIndex];
  }

  function isKeyboardOnlySelected() {
    const opt = selectedOption();
    return !!(opt && opt.dataset && opt.dataset.keyboardOnly === "1");
  }

  function keyboardOnlyMessage() {
    const opt = selectedOption();
    const note = opt && opt.dataset ? opt.dataset.note : "";
    if (note === "manchu") return "ë§Œì£¼ì–´(á ®á  á ¨á µá¡ )ëŠ” í‚¤ë³´ë“œ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. (ìŒì„± ì¸ì‹/ì½ê¸° ë¯¸ì§€ì›)";
    if (note === "tibetan") return "í‹°ë² íŠ¸ì–´(à½–à½¼à½‘à¼‹à½¦à¾à½‘à¼)ëŠ” í‚¤ë³´ë“œ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. (ìŒì„± ì¸ì‹/ì½ê¸° ë¯¸ì§€ì›)";
    if (note === "adlam") return `í’€ë¼ì–´(ì•„ë“¤ëŒ ë¬¸ì)ëŠ” í‚¤ë³´ë“œ ì…ë ¥/ë¶™ì—¬ë„£ê¸°ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. (ìŒì„± ì¸ì‹/ì½ê¸° ë¯¸ì§€ì›)

â€» ê¸€ìê°€ â–¡â–¡â–¡ë¡œ ë³´ì´ë©´ 'Noto Sans Adlam' ê°™ì€ í°íŠ¸ë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”.`;
    if (note === "baybayin") return `ë°”ì´ë°”ì´ì¸(Baybayin) ë¬¸ìëŠ” í‚¤ë³´ë“œ ì…ë ¥/ë¶™ì—¬ë„£ê¸°ë¡œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. (ìŒì„± ì¸ì‹/ì½ê¸° ë¯¸ì§€ì›)

â€» ê¸€ìê°€ â–¡â–¡â–¡ë¡œ ë³´ì´ë©´ 'Noto Sans Tagalog' ê°™ì€ í°íŠ¸ë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”.`;
    return "í‚¤ë³´ë“œ ì…ë ¥ ì „ìš©(ìŒì„± ë¯¸ì§€ì›) ì–¸ì–´ì…ë‹ˆë‹¤.";
  }

  function applyKeyboardOnlyUI() {
    if (isKeyboardOnlySelected()) {
      alert(keyboardOnlyMessage());
      statusEl.textContent = "í‚¤ë³´ë“œ ì…ë ¥ ì „ìš©(ìŒì„± ì¸ì‹ ë¯¸ì§€ì›)";
      startBtn.disabled = true;
      stopBtn.disabled = true;
    } else {
      startBtn.disabled = false;
      // stop ë²„íŠ¼ì€ ì¸ì‹ ì¤‘ì—ë§Œ í™œì„±í™”ë˜ë„ë¡ ê¸°ì¡´ ë¡œì§ì— ë§¡ê¹€
      if ((statusEl.textContent || "").includes("í‚¤ë³´ë“œ ì…ë ¥ ì „ìš©")) statusEl.textContent = "ëŒ€ê¸°";
    }
  }

  langSel.addEventListener("change", applyKeyboardOnlyUI);
  setTimeout(applyKeyboardOnlyUI, 0);
// TTS ìŒì„± ëª©ë¡ì´ ëŠ¦ê²Œ ë¡œë”©ë˜ëŠ” ë¸Œë¼ìš°ì €(íŠ¹íˆ Chrome) ëŒ€ì‘
  if ("speechSynthesis" in window) {
    speechSynthesis.onvoiceschanged = () => {};
  }


  function setStatus(t) { statusEl.textContent = t; }

  recog.onstart = () => {
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("ë“£ëŠ” ì¤‘ (" + recog.lang + ")");
  };
  recog.onend = () => {
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus("ëŒ€ê¸°");
  };
  recog.onerror = (e) => {
    setStatus("ì˜¤ë¥˜: " + e.error);
  };
  recog.onresult = (e) => {
  let t = e.results[e.results.length - 1][0].transcript;

  // ğŸ”´ zh-TWì¼ ë•Œë§Œ ê°„ì²´ â†’ ë²ˆì²´ ë³€í™˜
  if (langSel.value === "zh-TW") {
    t = simplifiedToTraditional(t);
  }

  window.__lastVoiceText = t;

  insertTextToCanvas(t);
};

  async function start() {
    if (typeof isKeyboardOnlySelected === "function" && isKeyboardOnlySelected()) { alert(keyboardOnlyMessage()); return; }
if (!window.isSecureContext) {
      alert("localhost/HTTPSì—ì„œ ì‹¤í–‰í•˜ì„¸ìš”.");
      return;
    }
    recog.lang = langSel.value;
    try {
      const s = await navigator.mediaDevices.getUserMedia({audio:true});
      s.getTracks().forEach(t=>t.stop());
      recog.start();
    } catch(e) {
      alert("ë§ˆì´í¬ ê¶Œí•œ í•„ìš”");
    }
  }

  startBtn.onclick = start;
  stopBtn.onclick = ()=>recog.stop();

  // ğŸ”Š Speak last text (or a short sample in selected language)
  const speakBtn = document.getElementById("vSpeak");
  speakBtn.onclick = () => {
    const lang = langSel.value;
    const last = (window.__lastVoiceText || "").trim();
    const sample = {
      "ko-KR": "ì•ˆë…•í•˜ì„¸ìš”",
      "en-US": "Hello",
      "ar-SA": "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…",
      "hi-IN": "à¤¨à¤®à¤¸à¥à¤¤à¥‡",
      "th-TH": "à¸ªà¸§à¸±à¸ªà¸”à¸µ",
      "km-KH": "áŸá½áŸáŸ’áá¸",
      "lo-LA": "àºªàº°àºšàº²àºàº”àºµ",
      "my-MM": "á€™á€„á€ºá€¹á€‚á€œá€¬á€•á€«",
      "ne-NP": "à¤¨à¤®à¤¸à¥à¤¤à¥‡",
	  "ja-JP": "ã“ã‚“ã«ã¡ã¯",
      "zh-CN": "ä½ å¥½",
      "mn-MN": "Ğ¡Ğ°Ğ¹Ğ½ Ğ±Ğ°Ğ¹Ğ½Ğ° ÑƒÑƒ",
	  "he-IL": "×©×œ×•×"
    };

    const text = last || sample[lang] || sample["en-US"];

    // âœ… TTS ì§€ì›/ìŒì„± ìœ ë¬´ ì•ˆë‚´
    if (!("speechSynthesis" in window)) {
      alert("ì´ ë¸Œë¼ìš°ì €ëŠ” TTS(ì½ê¸°)ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome/Edgeë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤.");
      return;
    }
    const voices = speechSynthesis.getVoices();
    if (!voices || voices.length === 0) {
      alert("TTS ìŒì„± ëª©ë¡ì„ ì•„ì§ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤. 1~2ì´ˆ ë’¤ì— ë‹¤ì‹œ ëˆŒëŸ¬ ì£¼ì„¸ìš”.");
      return;
    }
    const hasVoice = voices.some(v => v.lang === lang || (v.lang || "").startsWith(lang.split("-")[0]));
    if (!hasVoice) {
      alert("ì´ PC/ë¸Œë¼ìš°ì €ì—ëŠ” ì„ íƒí•œ ì–¸ì–´ì˜ TTS ìŒì„±ì´ ì—†ì–´ì„œ ì†Œë¦¬ê°€ ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n- í•´ê²°: Windows(ë˜ëŠ” OS)ì—ì„œ í•´ë‹¹ ì–¸ì–´ì˜ ìŒì„±(TTS)ì„ ì„¤ì¹˜í•˜ê±°ë‚˜,\n- ë‹¤ë¥¸ ë¸Œë¼ìš°ì €/PCì—ì„œ ì‹¤í–‰í•´ ë³´ì„¸ìš”.");
      return;
    }

    speakText(text, lang);
  };
})();
</script>

</body>
</html>